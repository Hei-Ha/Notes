{"./":{"url":"./","title":"简介","keywords":"","body":"Notes 简介 "},"src/frontEnd/":{"url":"src/frontEnd/","title":"前端","keywords":"","body":"JS 知识点 "},"src/frontEnd/js/":{"url":"src/frontEnd/js/","title":"JS","keywords":"","body":""},"src/frontEnd/js/undefined和null的区别.html":{"url":"src/frontEnd/js/undefined和null的区别.html","title":"undefined 和 null 的区别","keywords":"","body":"历史原因 刚开始，javascript 中只有 null，表示无的值，并且可以转为数字 0 。 但是设计者发现这样不够，有两个原因： 1、null 像在 java 里面一样，被当作是一个对象，但是 javascript 中 数据类型分为基本数据类型，和引用数据类型。作者觉得表示 无 的值，最好不是对象。 2、javascript 刚开始的版本没有错误处理机制，发生数据类型不匹配的时候，往往是自动转换类型，或者直接失败，如果 null 自动转为 0 ，错误很不容易被发现。 所以，作者又加上了一个 undefined 如何区分 null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。 用法 null 表示\"没有对象\"，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 undefined 表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 "},"src/frontEnd/js/原型和原型链.html":{"url":"src/frontEnd/js/原型和原型链.html","title":"原型和原型链","keywords":"","body":"原型链是什么？说一说原型链。 举个例子： 有一个对象 x = {}, 它有一个隐藏属性，叫 **???**, 这个隐藏属性，指向 Object.prototype，可以得出： x.__???__ === Object.prototype 也就是：x 的隐藏属性，等于 Object.prototype。在这里 x 的隐藏属性，就是 x 的原型，即： proto 这是原型的概念。 现在有另外一个 数组 Y = [], 它也有一个隐藏属性 proto****, 这个隐藏属性，指向 Array.prototype, 可以得出： Y.__proto__ === Array.prototype 也就是：Y 的原型，等于 Array.prototype 属性。 与此同时，Array 也有一个隐藏属性 proto，它等于 Object.prototype, 所以可以得出： Array.__proto__ === Object.prototype 所以，最终可以得出： Y.__proto__ => Array.__proto__ => Object.prototype 这就是原型链。 注：只有构造函数才有 prototype 属性。 js 中所有对象都有 **proto** 属性。 如何创建原型链。 直接修改对象的隐藏属性指向，比如： 声明一个函数 function F () {} Y = Object.create(F) Y.__proto__ === F.prototype 那么就会形成这样一个原型链： Y.__proto__ === F.prototype === Object.prototype 这样就创建了一个新的链条，新的原型链。 原型链解决了什么问题？ 在没有 Class 的情况下，实现了继承。 原型链缺点 与 class 相比，写起来比较复杂，并且不像 java 那样有私有属性。 在 父对象上声明 __ 开头这样的属性值，子对象也是能够访问的，只是默认约定不访问 __ 开头的属性。 "},"src/frontEnd/js/立即执行函数.html":{"url":"src/frontEnd/js/立即执行函数.html","title":"立即执行函数","keywords":"","body":"立即执行函数 是什么 立即执行函数，就是声明一个匿名函数，然后立即执行它。 举例： (function() { console.log('hello') }()) 匿名函数的作用： 在 ES6 之前，声明一个匿名函数。 优缺点： 优点：兼容性好。 缺点，语法不好看。 解决缺点：使用 ES6 的 let "},"src/frontEnd/js/闭包.html":{"url":"src/frontEnd/js/闭包.html","title":"闭包","keywords":"","body":"闭包 什么是闭包 闭包是一种语法特性。 js 的所有函数都支持闭包 // 对于一个函数来说，变量类型有：全局变量、局部变量、自由变量。 闭包 = 函数 + 自由变量（非全局变量，非局部变量） { let a = 1 function test() { // 这个函数访问了它外部的自由变量（不是全局变量），这个函数，和这个自由变量，就形成了一个闭包。 a = a + 1 } // 这里的自由变量不能是全局变量，因为如果是全局变量，在哪里都能访问，所以没办法区分是闭包提供的访问外部变量的能力，还是全局变量提供的能力。 } 一般将上面的代码防在非全局环境里面，即这样写： var test = function () { let a = 2 const res = () => { a = a + 1 } return res } // 这里的 a 和函数 res 形成了闭包 闭包有什么作用： 避免污染全局环境。 提供对局部变量的间接访问。 维持变量，避免被垃圾回收。 优缺点： 优点：简单、好用。 缺点，闭包使用不当，会导致内存泄漏。 解决办法：少用闭包，慎用闭包。 "},"src/frontEnd/js/this指向.html":{"url":"src/frontEnd/js/this指向.html","title":"this指向","keywords":"","body":"this 指向 this 绑定共有四种： 分别是： 默认绑定 隐式绑定 显示绑定 new 绑定优先级: 由高到低： new > 显示绑定 > 隐式绑定 > 默认绑定 逐个介绍： 1. 默认绑定 可以把这条规则看作是无法应用其他规则时候的默认规则。 function foo () { console.log(this.a) } var a = 2 foo() // 2 在调用 foo 的时候，默认将 this 指向全局对象。 但是在严格模式中，this 将会被绑定成 undefined, 因此在严格模式中，上述代码将会报错。 2. 隐式绑定 function foo() { console.log(this.a) } var obj = { a: 2, foo: foo } console.log(obj.foo()) // 2 当函数 foo 被调用的时候，他的前面加上了对 obj 的引用，这就是隐式绑定，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。即把 this 绑定到 obj 。 3. 显式绑定 使用 call, apply, bind 绑定 4. new 绑定 function foo(a) { this.a = a } var bar = new foo(2) console.log(bar.a) 使用 new 来调用 foo(...) 时，我们会创造一个新对象，并把它绑定到 foo(...)调用中的 this 上， new 是最后一种可以影响函数调用时候 this 绑定行为的方法。 "},"src/frontEnd/js/new做了什么.html":{"url":"src/frontEnd/js/new做了什么.html","title":"new做了什么","keywords":"","body":"New 做了什么 创建（或者说构造）一个全新的对象。 绑定 临时对象的原型 ： 将新对象的隐藏属性，指向构造函数的原型。这样可以使新对象获得构造函数原型的所有共有属性（赋值新对象的共有属性） 指定 this（新对象会被绑定到函数调用的 this） 改变 this 指向，将构造函数的 this 指向这个新对象。 执行构造方法 （赋值新对象的私有属性） 返回创建的新对象（如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个刚才创造的新对象。） "},"src/frontEnd/js/script标签的async和defer的区别.html":{"url":"src/frontEnd/js/script标签的async和defer的区别.html","title":"script标签的async和defer的区别","keywords":"","body":"script 标签的 async 和 defer 的区别 script 不加任何标签 这种情况，浏览器遇到 script 标签的时候，会立即加载 script 标签中的脚本，然后接着就执行。 defer 内容待更新 "},"src/gitOperate/":{"url":"src/gitOperate/","title":"Git","keywords":"","body":"git 常用命令 合并commit 为一个 // 合并指定版本号（不包含此版本） git rebase -i [commitid] :%s/pick/s/g 全局替换 pick 为 s 拉取远程分支到本地 git checkout -b 本地新建的分支名 origin/远程分支名 "},"src/regEx/":{"url":"src/regEx/","title":"正则表达式","keywords":"","body":"数字每三位添加逗号 String(123456789).replace(/(? "}}