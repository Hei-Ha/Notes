{"./":{"url":"./","title":"简介","keywords":"","body":"Notes 简介 "},"src/frontEnd/":{"url":"src/frontEnd/","title":"前端","keywords":"","body":"JS 知识点 "},"src/frontEnd/js/":{"url":"src/frontEnd/js/","title":"JS","keywords":"","body":""},"src/frontEnd/js/undefined和null的区别.html":{"url":"src/frontEnd/js/undefined和null的区别.html","title":"undefined 和 null 的区别","keywords":"","body":"历史原因 刚开始，javascript 中只有 null，表示无的值，并且可以转为数字 0 。 但是设计者发现这样不够，有两个原因： 1、null 像在 java 里面一样，被当作是一个对象，但是 javascript 中 数据类型分为基本数据类型，和引用数据类型。作者觉得表示 无 的值，最好不是对象。 2、javascript 刚开始的版本没有错误处理机制，发生数据类型不匹配的时候，往往是自动转换类型，或者直接失败，如果 null 自动转为 0 ，错误很不容易被发现。 所以，作者又加上了一个 undefined 如何区分 null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。 用法 null 表示\"没有对象\"，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 undefined 表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 "},"src/frontEnd/js/原型和原型链.html":{"url":"src/frontEnd/js/原型和原型链.html","title":"原型和原型链","keywords":"","body":"原型链是什么？说一说原型链。 举个例子： 有一个对象 x = {}, 它有一个隐藏属性，叫 **???**, 这个隐藏属性，指向 Object.prototype，可以得出： x.__???__ === Object.prototype 也就是：x 的隐藏属性，等于 Object.prototype。在这里 x 的隐藏属性，就是 x 的原型，即： proto 这是原型的概念。 现在有另外一个 数组 Y = [], 它也有一个隐藏属性 proto****, 这个隐藏属性，指向 Array.prototype, 可以得出： Y.__proto__ === Array.prototype 也就是：Y 的原型，等于 Array.prototype 属性。 与此同时，Array 也有一个隐藏属性 proto，它等于 Object.prototype, 所以可以得出： Array.__proto__ === Object.prototype 所以，最终可以得出： Y.__proto__ => Array.__proto__ => Object.prototype 这就是原型链。 注：只有构造函数才有 prototype 属性。 js 中所有对象都有 **proto** 属性。 如何创建原型链。 直接修改对象的隐藏属性指向，比如： 声明一个函数 function F () {} Y = Object.create(F) Y.__proto__ === F.prototype 那么就会形成这样一个原型链： Y.__proto__ === F.prototype === Object.prototype 这样就创建了一个新的链条，新的原型链。 原型链解决了什么问题？ 在没有 Class 的情况下，实现了继承。 原型链缺点 与 class 相比，写起来比较复杂，并且不像 java 那样有私有属性。 在 父对象上声明 __ 开头这样的属性值，子对象也是能够访问的，只是默认约定不访问 __ 开头的属性。 "},"src/frontEnd/js/立即执行函数.html":{"url":"src/frontEnd/js/立即执行函数.html","title":"立即执行函数","keywords":"","body":"立即执行函数 是什么 立即执行函数，就是声明一个匿名函数，然后立即执行它。 举例： (function() { console.log('hello') }()) 匿名函数的作用： 在 ES6 之前，声明一个匿名函数。 优缺点： 优点：兼容性好。 缺点，语法不好看。 解决缺点：使用 ES6 的 let "},"src/frontEnd/js/闭包.html":{"url":"src/frontEnd/js/闭包.html","title":"闭包","keywords":"","body":"闭包 什么是闭包 闭包是一种语法特性。 js 的所有函数都支持闭包 // 对于一个函数来说，变量类型有：全局变量、局部变量、自由变量。 闭包 = 函数 + 自由变量（非全局变量，非局部变量） { let a = 1 function test() { // 这个函数访问了它外部的自由变量（不是全局变量），这个函数，和这个自由变量，就形成了一个闭包。 a = a + 1 } // 这里的自由变量不能是全局变量，因为如果是全局变量，在哪里都能访问，所以没办法区分是闭包提供的访问外部变量的能力，还是全局变量提供的能力。 } 一般将上面的代码防在非全局环境里面，即这样写： var test = function () { let a = 2 const res = () => { a = a + 1 } return res } // 这里的 a 和函数 res 形成了闭包 闭包有什么作用： 避免污染全局环境。 提供对局部变量的间接访问。 维持变量，避免被垃圾回收。 优缺点： 优点：简单、好用。 缺点，闭包使用不当，会导致内存泄漏。 解决办法：少用闭包，慎用闭包。 "},"src/frontEnd/js/this指向.html":{"url":"src/frontEnd/js/this指向.html","title":"this指向","keywords":"","body":"this 指向 this 绑定共有四种： 分别是： 默认绑定 隐式绑定 显示绑定 new 绑定优先级: 由高到低： new > 显示绑定 > 隐式绑定 > 默认绑定 逐个介绍： 1. 默认绑定 可以把这条规则看作是无法应用其他规则时候的默认规则。 function foo () { console.log(this.a) } var a = 2 foo() // 2 在调用 foo 的时候，默认将 this 指向全局对象。 但是在严格模式中，this 将会被绑定成 undefined, 因此在严格模式中，上述代码将会报错。 2. 隐式绑定 function foo() { console.log(this.a) } var obj = { a: 2, foo: foo } console.log(obj.foo()) // 2 当函数 foo 被调用的时候，他的前面加上了对 obj 的引用，这就是隐式绑定，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。即把 this 绑定到 obj 。 3. 显式绑定 使用 call, apply, bind 绑定 4. new 绑定 function foo(a) { this.a = a } var bar = new foo(2) console.log(bar.a) 使用 new 来调用 foo(...) 时，我们会创造一个新对象，并把它绑定到 foo(...)调用中的 this 上， new 是最后一种可以影响函数调用时候 this 绑定行为的方法。 "},"src/frontEnd/js/new做了什么.html":{"url":"src/frontEnd/js/new做了什么.html","title":"new做了什么","keywords":"","body":"New 做了什么 创建（或者说构造）一个全新的对象。 绑定 临时对象的原型 ： 将新对象的隐藏属性，指向构造函数的原型。这样可以使新对象获得构造函数原型的所有共有属性（赋值新对象的共有属性） 指定 this（新对象会被绑定到函数调用的 this） 改变 this 指向，将构造函数的 this 指向这个新对象。 执行构造方法 （赋值新对象的私有属性） 返回创建的新对象（如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个刚才创造的新对象。） "},"src/frontEnd/js/script标签的async和defer的区别.html":{"url":"src/frontEnd/js/script标签的async和defer的区别.html","title":"script标签的async和defer的区别","keywords":"","body":"script 标签的 async 和 defer 的区别 script 不加任何标签 这种情况，浏览器遇到 script 标签的时候，会立即加载 script 标签中的脚本，然后接着就执行。 defer 内容待更新 "},"src/frontEnd/css/":{"url":"src/frontEnd/css/","title":"css","keywords":"","body":"CSS "},"src/frontEnd/css/reflowRepaint.html":{"url":"src/frontEnd/css/reflowRepaint.html","title":"回流、重绘","keywords":"","body":"回流、重绘 回流 什么是回流： 当 Render Tree 中部分或全部元素的尺寸、结构、或某些属性发生改变时， 浏览器重新渲染部分或全部文档的过程称为回流。 会导致回流的操作： 面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover） 查询某些属性或调用某些方法 常见的会导致回流的操作有： clientWidth, clientHeight, clientTop, clientLeft offsetWidth,offsetHeight,offsetTop,offsetLeft scrollWidth, scrollHeight, scrollTop, scrollLeft scrollIntoView(), scrollIntoViewIfNeeded(), getComputedStyle(), getBoundingClientRect(), scrollTo() 重绘 什么是重绘： 当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等）， 浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。 回流比重绘的代价要更高。 有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。 现代浏览器会对频繁的回流或重绘操作进行优化： 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的， 浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。 当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth, clientHeight, clientTop, clientLeft offsetWidth, offsetHeight, offsetTop, offsetLeft scrollWidth, scrollHeight, scrollTop, scrollLeft width, height, getComputedStyle(), getBoundingClientRect() 这是因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关， 浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免： 避免使用table布局。 尽可能在DOM树的最末端改变class。 避免设置多层内联样式。 将动画效果应用到position属性为absolute或fixed的元素上。 避免使用CSS表达式（例如：calc()）。 "},"src/frontEnd/css/clearFloat.html":{"url":"src/frontEnd/css/clearFloat.html","title":"清除浮动","keywords":"","body":"清除浮动 给父元素加上下面的类： .parent::after { clear: both; content: ''; display: block; } 使用 BFC 参考链接 "},"src/frontEnd/css/水平垂直居中.html":{"url":"src/frontEnd/css/水平垂直居中.html","title":"水平垂直居中方法","keywords":"","body":"水平垂直居中的方法 1. 借助 table 这种方法父、子元素不需要设置宽高（这里设置宽高是为了截图效果）。 .parent { width: 200px; height: 200px; display: table; background-color: cornflowerblue; } .child { display: table-cell; background-color: aqua; vertical-align: middle; text-align: center; } 子元素 效果 2. 利用伪元素 这种方法父、子元素不需要设置宽高（这里设置宽高是为了截图效果）。 需要给伪元素设置高度撑满父元素。 利用伪元素 .parent { width: 300px; height: 300px; background-color: cornflowerblue; text-align: center; } .parent::before, .parent::after { content:''; height: 100%; display: inline-block; vertical-align: middle; } .child { display: inline-block; vertical-align: middle; background-color: red; } 效果 3. 绝对定位 + 负 margin 此种方法父元素和子元素都必须设置宽高 绝对定位 + 负margin .parent{ height: 300px; width: 300px; position: relative; background-color: cornflowerblue; } .child{ width: 100px; height: 100px; background-color: aqua; position: absolute; top: 50%; left: 50%; margin-left: -50px; margin-top: -50px; } 效果 4. transform: translate() 这种方法和 负margin 一样，就是把 负的margin 换成 transform: translate(-50%, -50%)， 父元素需要规定宽高，子元素不用规定宽高。 绝对定位 + transform: translate(-50%, -50%) .parent { height: 300px; width: 300px; position: relative; background-color: cornflowerblue; } .child { /*width: 100px;*/ /*height: 100px;*/ background-color: aqua; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 效果 5. 绝对定位 + margin: auto 这种方法父子元素都需要给定宽高。 绝对定位 + margin: auto .parent{ height: 300px; width: 300px; position: relative; background-color: cornflowerblue; } .child{ width: 100px; height: 100px; background-color: aqua; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; } 效果 6. flex flex 布局不需要给父元素、子元素设置宽高（此处父元素设置宽高是为了截图效果）。 flex .parent{ width: 300px; height: 300px; display: flex; justify-content: center; align-items: center; background-color: cornflowerblue; } .child { background-color: aqua; } 效果 "},"src/frontEnd/handWritten/":{"url":"src/frontEnd/handWritten/","title":"手写","keywords":"","body":"手写代码系列 "},"src/frontEnd/handWritten/call,apply,bind.html":{"url":"src/frontEnd/handWritten/call,apply,bind.html","title":"手写：call、apply、bind","keywords":"","body":"手写：call、apply、bind var year = 2020 obj = { year: 2021 } const getDate = function (month, day) { return `${this.year}-${month}-${day}` } console.log(getDate.call(null, 3, 1)) // 2020-3-1 console.log(getDate.call(obj, 5, 2)) // 2021-5-2 console.log(getDate.apply(obj, [6, 8])) // 2021-6-8 console.log(getDate.bind(obj)(7, 9)) // 2021-7-9 相同点： 三者都可以改变 this 指向 不同点： call 和 apply 是立即执行的，bind 返回一个函数，并不会执行，一般在后面跟上 () 来立即执行返回的函数。 传参方式不同 call 可以传多个参数，第一个参数是要绑定的 this 对象，剩下的参数由逗号隔开，依次传入getDate 函数中 apply 只能有两个参数，第一个参数是要绑定的 this 对象，第二个参数是一个数组，数组中的元素作为 getDate 函数的参数 bind 也可以传递多个参数，参数规则类似 call，第一个参数为要绑定的 this 对象，后面的参数传递给要执行函数作为参数 由于bind 返回的是一个函数，所以需要在后面加上 () 去执行返回的函数， 此()里面也可以加参数。 手写代码： call Function.prototype.call2 = function(context, ...args) { // 此时的 this 指的是 getDate 这个函数， context = (context === undefined || context === null) ? window : context context.__fn = this // 把 this 存起来，以备后面调用 let result = context.__fn(...args) delete context.__fn // 删除自己添加的属性 return result } // 调用 call2 console.log(getDate.call2(obj, 5, 2)) // 2021-9-2 apply Function.prototype.apply2 = function(context, args) { context = (context === undefined || context === null) ? window : context context.__fn = this let result = context.__fn(...args) delete context.__fn return result } // 调用 apply2 console.log(getDate.apply2(obj, [10, 1])) // 2021-10-1 bind Function.prototype.bind2 = function (context, ...args1) { context = (context === undefined || context === null) ? window : context let self = this return function (...args2) { context.__fn = self let result = context.__fn(...[...args1, ...args2]) delete context.__fn return result } } // 调用 bind2 console.log(getDate.bind2(obj)(1, 9)) // 2021-1-9 "},"src/frontEnd/handWritten/数组去重.html":{"url":"src/frontEnd/handWritten/数组去重.html","title":"手写：数组去重","keywords":"","body":"手写：数组去重 循环 // 这种情况能也可以区分开 数字和字符串的区别 const arrs = [1,2,2,'2',5,6,6] const noRepeat = (arr) => { const res = [] for (let i = 0; i 利用 Set const arr = [1,2,2,2,5,6,6] const noRepeat = (arr) => { return Array.from(new Set(arr)) // 或者这样写 // return [...new Set(arr)] } console.log(noRepeat(arr)) // (4) [1, 2, 5, 6] 利用 Map const arrs = [1,2,2,'2',5,6,6] const noRepeat = (arr) => { const mapData = new Map() for (let i = 0; i "},"src/frontEnd/handWritten/深拷贝.html":{"url":"src/frontEnd/handWritten/深拷贝.html","title":"深拷贝","keywords":"","body":"手写：深拷贝 以下几种方法都可以实现深拷贝，各有优劣 利用 JSON 方法 // 假定 a 是要拷贝的对象 const res = JSON.parse(JSON.stringify(a)) 这种方法的缺点： 不支持拷贝正则，Date，undefined,函数 不支持环形引用 使用递归： 递归 判断类型，不用类型用不同的方法拷贝 检查环形引用 不拷贝继承过来的属性 const deepClone = (param, mapData) => { if (!mapData) { // 将 mapData 映射作为参数传进函数体内，防止多次深拷贝创建的 mapData 相互影响， mapData = new Map() } if (param instanceof Object) { // 如果 params 是对象需要单独处理 if (mapData.get(param)) { return mapData.get(param) } let result = undefined if (param instanceof Function) { // 如果是函数 if (param.prototype) { // 如果是普通函数 result = function () { param.apply(this, arguments) } } else { // 不是普通函数，是箭头函数（箭头函数没有 prototye 属性） result = () => { param.call(undefined, ...arguments) } } } else if (param instanceof Array) { // 如果是数组 result = [] } else if (param instanceof Date) { // 如果是日期 result = new Date(param - 0) // 利用时间戳去重新生成一个日期 }else if (param instanceof RegExp) { // 如果是正则 // result = new RegExp(param) result = new RegExp(param.source, a.flags) } else { // 其他则视为普通对象 result = {} } // 在这里利用 mapData 去存储已经拷贝过的值，用来避免遇到 环形引用。 mapData.set(param, result) // 这里将其他属性，依次遍历重新拷贝一遍 // const keys = Object.keys(param) for(let key in param) { if (param.hasOwnProperty(key)) { // 只遍历 param 自己的可枚举属性，不遍历继承过来的属性 result[key] = deepClone(param[key], mapData) } } return result } else { // param 是基本数据类型 return param } } 使用： const a = { one: [1,2,3,4, [9,8,7]], two: function () { console.log('two') }, three: new Date(), four: () => { console.log('箭头函数') } } "},"src/frontEnd/handWritten/Promise.all.html":{"url":"src/frontEnd/handWritten/Promise.all.html","title":"Promise.all","keywords":"","body":"手写：Promise.all Promise.all2 = (arrayList) => { return new Promise((resolve, reject) => { const result = [] let count = 0 arrayList.map((item, index) => { item.then((data) => { result[index] = data count = count + 1 if (count === arrayList.length - 1) { resolve(result) } }, (reason) => { reject(reason) }) }) }) } "},"src/frontEnd/handWritten/ajax.html":{"url":"src/frontEnd/handWritten/ajax.html","title":"Ajax","keywords":"","body":"手写：Ajax var XMLRequest = new XMLHTTPRequest() XMLRequest.open('GET', '/xxx?', true) // 第三个参数：是否为异步 // 如果是 post 请求，必须要加上请求头。setRequestHeader 必须在 open 之后，send 之前 // XMLRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); XMLRequest.onreadystatechange = function () { if (XMLRequest.readyState === 4) { if (XMLRequest.status >= 200 && XMLRequest.status "},"src/frontEnd/handWritten/防抖、节流.html":{"url":"src/frontEnd/handWritten/防抖、节流.html","title":"防抖、节流","keywords":"","body":"手写：防抖、节流函数 防抖： 使用场景： 比如，当需要根据窗口大小调整页面内容的时候，如果用户不断的放大缩小页面，会导致不停的计算。 使用防抖函数，只有当用户停止调整页面窗口的时候，再去计算。 function goBack() { console.log('回到泉水') } const timer = null function B() { if (timer) { // 如果回城被打断或者再次按回城键，则需要再次调用回城方法，从 0 开始回城 clearTimeout(timer) } timer = setTimeout(() => { goBack() timer = null }, 3000) } // 防抖升级版： const debounce = (fn, time) => { const timer = null return () => { if (timer) { clearTimeout(timer) } else { timer = setTimeout(() => { fn() timer = null }, time) } } } // 使用： const Back = debounce(B, 3000) 节流： 使用场景： 页面上某个按钮，3秒内只能点击一次。类似这样的功能的时候，需要用到节流。 function shanXian() { console.log('向指定方向闪现一段距离') } const isCD = false const timer = null function D() { if (isCD) { return } shanXian() isCD = true timer = setTimeout(() => { isCD = false timer = null }, 3000) } // 节流升级版： // 能够将任意函数改为截流函数： const throttle = (fn, time) => { const isCD = false const timer = null return () => { if (isCD) { return } fn() isCD = true timer = setTimeout(() => { isCD = false timer = null }, time) } } "},"src/frontEnd/handWritten/实现继承.html":{"url":"src/frontEnd/handWritten/实现继承.html","title":"实现继承","keywords":"","body":"手写：实现继承 ES5 function Animal(legs) { this.legsNumber = legs } Animal.prototype.kind = function(kind) { console.log(kind) } // Dog 继承 Animal function Dog(name) { Animal.call(this, 2) // Dog 继承 Animal 的属性 this.name = name } // Dog.prototype.__proto__ = Animal.prototype 下面三句代码代替这段代码，因为浏览器不支持直接修改 __proto__ 属性 let emptyAnimal = function() {} // 声明一个空的函数，用来替换 Animal emptyAnimal.prototype = Animal.prototype // 将 Animal 函数体中的代码替换掉，因为在 Animal.call(this. 2) 中已经执行过了。 Dog.prototype = new emptyAnimal() // 因为 new 的操作中会执行构造函数，所以需要提前清除构造函数的函数体，防止多添加属性 ES6 class Animal { constructor(legs) { this.legsNumber = legs } run() { console.log('run') } } class Dog extends Animal { constructor(name) { super(2) this.name = name } say() { console.log('say') } } "},"src/frontEnd/handWritten/实现一个类.html":{"url":"src/frontEnd/handWritten/实现一个类.html","title":"实现一个类","keywords":"","body":"手写：实现一个类 ES5 function Dog1 (name) { this.name = name this.eyes = 2 } Dog.prototype.say = function () { console.log(\"汪\") } Dog.prototype.run = function() { conslle.log('跑') } const dog1 = new Dog1('第一个') ES6 class Dog2 { constructor(name) { this.name = name this.eyes = 2 } say() { console.log('汪') } run () { console.log('跑') } } const dog2 = new Dog2('第二个') "},"src/frontEnd/handWritten/发布订阅.html":{"url":"src/frontEnd/handWritten/发布订阅.html","title":"发布订阅","keywords":"","body":"手写：发布订阅 class Event { constructor() { this.eventMap = {} } // 添加订阅 on(type, callback) { this.eventMap[type] = this.eventMap[type] || [] this.eventMap[type].push(callback) } // 发布 emit(type, ...args) { if (!this.eventMap[type]) { return } this.eventMap[type].forEach((item) => { item(args) }) } // 接触订阅 off(type, callback) { if (!this.eventMap[type]) { return } const index = this.eventMap[type].indexOf(callback) if (index { callback(params) this.off(type, fn) } this.on(type, fn) } } // 以下可以不看 // const eventBus = { // map: {}, // // 订阅事件 // on: (name, fn) => { // eventBus.map[name] = eventBus.map[name] || [] // eventBus.map[name].push(fn) // }, // emit: (name, params) => { // if (!eventBus.map[name]) { return } // eventBus.map((item) => { // item(params) // }) // }, // off: (name, fn) => { // if (!eventBus.map[name]) { return } // const index = eventBus.map[name].indexOf(fn) // if (index "},"src/frontEnd/html/SVG和Canvas的区别.html":{"url":"src/frontEnd/html/SVG和Canvas的区别.html","title":"SVG 和 Canvas的区别","keywords":"","body":"SVG 和 Canvas 的区别 区别 Canvas 主要是用来绘制 2D 图形的。 SVG 主要是用标签来绘制不规则矢量图的。 SVG 渲染节点过多的时候渲染慢，Canvas 性能更好一点，但是写起来比较麻烦。 "},"src/frontEnd/浏览器/Session_Cookie_LocalStorage_SessionStorage.html":{"url":"src/frontEnd/浏览器/Session_Cookie_LocalStorage_SessionStorage.html","title":"session、cookie、localStorage、sessionStorage区别","keywords":"","body":"Session、Cookie、LocalStorage、SessionStorage 区别 Cookie 和 LocalStorage 1、主要区别是 Cookie 会被发送到服务器，而 LocalStorage 是存储在浏览器本地的，不会发送到服务器。 2、Cookie 一般大小是4k 左右，LocalStorage 大小是 5M 左右(具体看浏览器的实现) LocalStorage 和 SessionStorage 1、LocalStorage 一般不会自动过期（除非用户手动删除） 2、SessionStorage 在会话结束时，由浏览器决定何时清空，（一般在页签关闭的时候清空） Cookie 和 Session 1、Cookie 存在浏览器里面，Session 存在服务器文件里 2、Session 是基于 Cookie 实现的，具体做法就是把 SessionID 存放在 Cookie 里面，服务器里面存着对应 sessionID 的数据 "},"src/frontEnd/计算机网络/七层模型.html":{"url":"src/frontEnd/计算机网络/七层模型.html","title":"七层模型","keywords":"","body":"七层模型 "},"src/frontEnd/HTTP相关/":{"url":"src/frontEnd/HTTP相关/","title":"HTTP 相关","keywords":"","body":""},"src/frontEnd/HTTP相关/HTTPS加密过程.html":{"url":"src/frontEnd/HTTP相关/HTTPS加密过程.html","title":"HTTP 加密过程","keywords":"","body":"HTTPS 加密过程 简介： 由于 HTTP 请求和相应的报文都是明文的，为了给 HTTP 增加安全性，在 HTTP 上加了一层安全协议 （SSL/TLS） 也就是 ： HTTPS = HTTP + SSL(或者 TLS) 前置知识： 加密一般是通过 公钥和私钥，而这一对 公钥和私钥 一般存放在 服务器上，服务器会对外公开自己的 公钥，不会公开自己的 私钥。 HTTPS 加密过程： 经过 TCP 三次握手之后会经历如下过程： 客户端 ：C服务端：S C 向 S 发送一下信息，例如：TLS 版本、客户端支持的加密套件、并生成一个随机数，记为：随机数1 S 收到消息后，确认支持的 TLS 版本，和加密套件，并且也会生成一个随机数（记为：随机数2），发给 C。 同时也会向 C 发送 公钥、证书。都发送完毕后，告诉客户端发送完毕了。 这时候 C 会再生成一个 随机数（记为：随机数3），也叫预主密钥。这个 预主密钥不会直接发送出去，而是刚才接收到的公钥进行加密，加密后再发送给 S。 S 收到加密后的 预主密钥 后，会用自己的 私钥 去解密，得到客户端生成的 预主密钥。此时，只有 C 和 S 知道真正的 预主密钥。（除非服务器的 私钥 被泄漏） C 通过 随机数1、随机数2、预主密钥，生成一个会话密钥， S 通过 随机数1、随机数2、预主密钥，生成一个会话密钥， 这个时候C 和 S 的会话密钥是相同的。 C 和 S 得到一个相同的会话密钥，以后的信息传输就会利用这个会话密钥进行加密。 也就是说，第五步以前是非对称加密，第5步以后就是对称加密了。 为什么之后用 对称加密 因为当 C 和 S 得到相同的 会话密钥之后，就相当于双方有一个共同约定的加密方式，没有第三方知道。用会话密钥加密，就能够保证信息的安全性。 非对称加密比较消耗资源，所以后面就使用对称加密。 "},"src/frontEnd/HTTP相关/HTTP状态码.html":{"url":"src/frontEnd/HTTP相关/HTTP状态码.html","title":"HTTP 状态码","keywords":"","body":"HTTP 常用状态码 1xx：临时相应（表示临时响应并需要请求者继续执行操作的状态代码） 100 （继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 102 此状态代码主要用于与Link 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源 2xx：（成功）表示成功处理了请求的状态代码 200 请求成功。成功的含义取决于HTTP方法：GET：资源已被提取并在消息正文中传输。HEAD：实体标头位于消息正文中。POST：描述动作结果的资源在消息体中传输。TRACE：消息正文包含服务器收到的请求消息 201 该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。 202 请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 3xx:重定向 301：永久重定向被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。 如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 302：临时重定向请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。 只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 304：未被修改如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变， 则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾 4xx（请求错误）：码表示请求可能出错，妨碍了服务器的处理。 400 Bad Request 语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 请求参数有误 401 （Unauthorized未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应 403 Forbidden（禁止） 服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助， 而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行， 那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。 404 Not Found服务器找不到请求的网页。 405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源 5xx: 服务器错误 500 Internal Server Error服务器遇到了不知道如何处理的情况 502 Bad Gateway此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。 503 Service Unavailable 服务器没有准备好处理请求，此时服务器不可用。 "},"src/frontEnd/HTTP相关/三次握手_四次挥手.html":{"url":"src/frontEnd/HTTP相关/三次握手_四次挥手.html","title":"三次握手、四次挥手","keywords":"","body":"三次握手、四次挥手 三次握手的根本目的是为了让客户端和服务端都能够确认对方 发送和确认 的能力是正常的。 三次握手： 客户端先发一个 SYN 的包，想要和服务端建立连接。假如序号为 x，表示这是第 x 个链接。 服务端接收到 SYN(x) 的包后，表示同意建立链接，并返回 ACK(x+1) 和 SYN(y)。 ACK(x+1)表示对序号为x 的链接的同意。 SYN(y)表示服务端要和客户端建立链接的请求。 客户端接收到服务端的链接请求后，再返回 ACK(y+1) 表示同意客户端的链接 第一步，服务端知道客户端的发送能力是正常的。第二步，客户端知道服务端的发送能力和接受能力是正常的。第三部，服务端知道客户端的接受能力是正常的。 四次挥手： 客户端首先向服务器端发送要断开的请求： FIN(seq = x) 服务器同意，并向客户端发送： ACK(seq=x+1) 服务器再次向客户端发送： FIN(seq=y) 客户端向服务端发送： ACK(seq=y+1) 为什么 四次挥手中的2、3步骤不合并？因为 2、3、中间，服务器可能还有数据要处理，处理完了才能开始断开。 "},"src/frontEnd/Vue/":{"url":"src/frontEnd/Vue/","title":"Vue","keywords":"","body":"Vue "},"src/frontEnd/Vue/vue双向绑定.html":{"url":"src/frontEnd/Vue/vue双向绑定.html","title":"vue的双向绑定","keywords":"","body":"vue2 双向绑定 vue2 的双向绑定一般是用过 v-model 使用的v-model 是 vue2 双向绑定的一个语法糖，具体是结合了： v-bind:value和 v-on:input 来实现的， v-bind:value实现了 data --> UI 的单向绑定 v-on:input实现了 UI --> data 的单向绑定 两者结合，就形成了双向绑定 v-bind:value的具体实现是借助了 Object.defineprototype 函数，给数据的 getter和 setter属性，修改，监听数据修改的时机，进而去更新 UI v-on是通过 template给 Dom添加监听事件， Dom input的值改变了，就回去更新 data "},"src/构建工具/":{"url":"src/构建工具/","title":"webpack","keywords":"","body":"构建工具 "},"src/构建工具/webpack构建流程.html":{"url":"src/构建工具/webpack构建流程.html","title":"webpack 构建流程","keywords":"","body":"webpack 构建流程 初始化参数：从配置文件中和 shell 语句中读取、合并参数，得出最终的参数 开始编译：用上一步得到的参数，初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译。 确定入口：根据配置中的 entry 找出所有入口文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块被编译后的最的最终内容，以及他们之间的依赖关系。 完成模块编译：再经过第四步使用 Loader 翻译完所有的模块后，得到了每个模块翻译后的最终内容以及它们之间的依赖关系。 输出资源(emit)：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk ,再把每个 Chunk 转换成一个独立的文件加入到输出列表，这一步是可以修改输出内容的最后机会。 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 在以上整个过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 Api 改变 Webpack 的输出结果。 "},"src/gitOperate/":{"url":"src/gitOperate/","title":"Git","keywords":"","body":"git 常用命令 合并commit 为一个 // 合并指定版本号（不包含此版本） git rebase -i [commitid] :%s/pick/s/g 全局替换 pick 为 s 拉取远程分支到本地 git checkout -b 本地新建的分支名 origin/远程分支名 "},"src/regEx/":{"url":"src/regEx/","title":"常用正则表达式","keywords":"","body":"常用正则表达式 数字每三位添加逗号 String(123456789).replace(/(? "}}