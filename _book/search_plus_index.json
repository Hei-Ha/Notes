{"./":{"url":"./","title":"简介","keywords":"","body":"Notes 简介 "},"src/frontEnd/":{"url":"src/frontEnd/","title":"前端","keywords":"","body":"JS 知识点 "},"src/frontEnd/js/":{"url":"src/frontEnd/js/","title":"JS","keywords":"","body":""},"src/frontEnd/js/undefined和null的区别.html":{"url":"src/frontEnd/js/undefined和null的区别.html","title":"undefined 和 null 的区别","keywords":"","body":"历史原因 刚开始，javascript 中只有 null，表示无的值，并且可以转为数字 0 。 但是设计者发现这样不够，有两个原因： 1、null 像在 java 里面一样，被当作是一个对象，但是 javascript 中 数据类型分为基本数据类型，和引用数据类型。作者觉得表示 无 的值，最好不是对象。 2、javascript 刚开始的版本没有错误处理机制，发生数据类型不匹配的时候，往往是自动转换类型，或者直接失败，如果 null 自动转为 0 ，错误很不容易被发现。 所以，作者又加上了一个 undefined 如何区分 null是一个表示\"无\"的对象，转为数值时为0；undefined是一个表示\"无\"的原始值，转为数值时为NaN。 用法 null 表示\"没有对象\"，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 undefined 表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 "},"src/frontEnd/js/原型和原型链.html":{"url":"src/frontEnd/js/原型和原型链.html","title":"原型和原型链","keywords":"","body":"原型链是什么？说一说原型链。 举个例子： 有一个对象 x = {}, 它有一个隐藏属性，叫 **???**, 这个隐藏属性，指向 Object.prototype，可以得出： x.__???__ === Object.prototype 也就是：x 的隐藏属性，等于 Object.prototype。在这里 x 的隐藏属性，就是 x 的原型，即： proto 这是原型的概念。 现在有另外一个 数组 Y = [], 它也有一个隐藏属性 proto****, 这个隐藏属性，指向 Array.prototype, 可以得出： Y.__proto__ === Array.prototype 也就是：Y 的原型，等于 Array.prototype 属性。 与此同时，Array 也有一个隐藏属性 proto，它等于 Object.prototype, 所以可以得出： Array.__proto__ === Object.prototype 所以，最终可以得出： Y.__proto__ => Array.__proto__ => Object.prototype 这就是原型链。 注：只有构造函数才有 prototype 属性。 js 中所有对象都有 **proto** 属性。 如何创建原型链。 直接修改对象的隐藏属性指向，比如： 声明一个函数 function F () {} Y = Object.create(F) Y.__proto__ === F.prototype 那么就会形成这样一个原型链： Y.__proto__ === F.prototype === Object.prototype 这样就创建了一个新的链条，新的原型链。 原型链解决了什么问题？ 在没有 Class 的情况下，实现了继承。 原型链缺点 与 class 相比，写起来比较复杂，并且不像 java 那样有私有属性。 在 父对象上声明 __ 开头这样的属性值，子对象也是能够访问的，只是默认约定不访问 __ 开头的属性。 "},"src/frontEnd/js/立即执行函数.html":{"url":"src/frontEnd/js/立即执行函数.html","title":"立即执行函数","keywords":"","body":"立即执行函数 是什么 立即执行函数，就是声明一个匿名函数，然后立即执行它。 举例： (function() { console.log('hello') }()) 匿名函数的作用： 在 ES6 之前，声明一个匿名函数。 优缺点： 优点：兼容性好。 缺点，语法不好看。 解决缺点：使用 ES6 的 let "},"src/frontEnd/js/闭包.html":{"url":"src/frontEnd/js/闭包.html","title":"闭包","keywords":"","body":"闭包 什么是闭包 闭包是一种语法特性。 js 的所有函数都支持闭包 // 对于一个函数来说，变量类型有：全局变量、局部变量、自由变量。 闭包 = 函数 + 自由变量（非全局变量，非局部变量） { let a = 1 function test() { // 这个函数访问了它外部的自由变量（不是全局变量），这个函数，和这个自由变量，就形成了一个闭包。 a = a + 1 } // 这里的自由变量不能是全局变量，因为如果是全局变量，在哪里都能访问，所以没办法区分是闭包提供的访问外部变量的能力，还是全局变量提供的能力。 } 一般将上面的代码防在非全局环境里面，即这样写： var test = function () { let a = 2 const res = () => { a = a + 1 } return res } // 这里的 a 和函数 res 形成了闭包 闭包有什么作用： 避免污染全局环境。 提供对局部变量的间接访问。 维持变量，避免被垃圾回收。 优缺点： 优点：简单、好用。 缺点，闭包使用不当，会导致内存泄漏。 解决办法：少用闭包，慎用闭包。 "},"src/frontEnd/js/this指向.html":{"url":"src/frontEnd/js/this指向.html","title":"this指向","keywords":"","body":"this 指向 this 绑定共有四种： 分别是： 默认绑定 隐式绑定 显示绑定 new 绑定优先级: 由高到低： new > 显示绑定 > 隐式绑定 > 默认绑定 逐个介绍： 1. 默认绑定 可以把这条规则看作是无法应用其他规则时候的默认规则。 function foo () { console.log(this.a) } var a = 2 foo() // 2 在调用 foo 的时候，默认将 this 指向全局对象。 但是在严格模式中，this 将会被绑定成 undefined, 因此在严格模式中，上述代码将会报错。 2. 隐式绑定 function foo() { console.log(this.a) } var obj = { a: 2, foo: foo } console.log(obj.foo()) // 2 当函数 foo 被调用的时候，他的前面加上了对 obj 的引用，这就是隐式绑定，隐式绑定会把函数调用中的 this 绑定到这个上下文对象。即把 this 绑定到 obj 。 3. 显式绑定 使用 call, apply, bind 绑定 4. new 绑定 function foo(a) { this.a = a } var bar = new foo(2) console.log(bar.a) 使用 new 来调用 foo(...) 时，我们会创造一个新对象，并把它绑定到 foo(...)调用中的 this 上， new 是最后一种可以影响函数调用时候 this 绑定行为的方法。 "},"src/frontEnd/js/new做了什么.html":{"url":"src/frontEnd/js/new做了什么.html","title":"new做了什么","keywords":"","body":"New 做了什么 创建（或者说构造）一个全新的对象。 绑定 临时对象的原型 ： 将新对象的隐藏属性，指向构造函数的原型。这样可以使新对象获得构造函数原型的所有共有属性（赋值新对象的共有属性） 指定 this（新对象会被绑定到函数调用的 this） 改变 this 指向，将构造函数的 this 指向这个新对象。 执行构造方法 （赋值新对象的私有属性） 返回创建的新对象（如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个刚才创造的新对象。） "},"src/frontEnd/js/script标签的async和defer的区别.html":{"url":"src/frontEnd/js/script标签的async和defer的区别.html","title":"script标签的async和defer的区别","keywords":"","body":"script 标签的 async 和 defer 的区别 script 不加任何标签 这种情况，浏览器遇到 script 标签的时候，会立即加载 script 标签中的脚本，然后接着就执行。 defer 内容待更新 "},"src/frontEnd/handWritten/":{"url":"src/frontEnd/handWritten/","title":"手写","keywords":"","body":"手写代码系列 "},"src/frontEnd/handWritten/call,apply,bind.html":{"url":"src/frontEnd/handWritten/call,apply,bind.html","title":"手写：call、apply、bind","keywords":"","body":"手写：call、apply、bind var year = 2020 obj = { year: 2021 } const getDate = function (month, day) { return `${this.year}-${month}-${day}` } console.log(getDate.call(null, 3, 1)) // 2020-3-1 console.log(getDate.call(obj, 5, 2)) // 2021-5-2 console.log(getDate.apply(obj, [6, 8])) // 2021-6-8 console.log(getDate.bind(obj)(7, 9)) // 2021-7-9 相同点： 三者都可以改变 this 指向 不同点： call 和 apply 是立即执行的，bind 返回一个函数，并不会执行，一般在后面跟上 () 来立即执行返回的函数。 传参方式不同 call 可以传多个参数，第一个参数是要绑定的 this 对象，剩下的参数由逗号隔开，依次传入getDate 函数中 apply 只能有两个参数，第一个参数是要绑定的 this 对象，第二个参数是一个数组，数组中的元素作为 getDate 函数的参数 bind 也可以传递多个参数，参数规则类似 call，第一个参数为要绑定的 this 对象，后面的参数传递给要执行函数作为参数 由于bind 返回的是一个函数，所以需要在后面加上 () 去执行返回的函数， 此()里面也可以加参数。 手写代码： call Function.prototype.call2 = function(context, ...args) { // 此时的 this 指的是 getDate 这个函数， context = (context === undefined || context === null) ? window : context context.__fn = this // 把 this 存起来，以备后面调用 let result = context.__fn(...args) delete context.__fn // 删除自己添加的属性 return result } // 调用 call2 console.log(getDate.call2(obj, 5, 2)) // 2021-9-2 apply Function.prototype.apply2 = function(context, args) { context = (context === undefined || context === null) ? window : context context.__fn = this let result = context.__fn(...args) delete context.__fn return result } // 调用 apply2 console.log(getDate.apply2(obj, [10, 1])) // 2021-10-1 bind Function.prototype.bind2 = function (context, ...args1) { context = (context === undefined || context === null) ? window : context let self = this return function (...args2) { context.__fn = self let result = context.__fn(...[...args1, ...args2]) delete context.__fn return result } } // 调用 bind2 console.log(getDate.bind2(obj)(1, 9)) // 2021-1-9 "},"src/frontEnd/handWritten/数组去重.html":{"url":"src/frontEnd/handWritten/数组去重.html","title":"手写：数组去重","keywords":"","body":"手写：数组去重 循环 // 这种情况能也可以区分开 数字和字符串的区别 const arrs = [1,2,2,'2',5,6,6] const noRepeat = (arr) => { const res = [] for (let i = 0; i 利用 Set const arr = [1,2,2,2,5,6,6] const noRepeat = (arr) => { return Array.from(new Set(arr)) // 或者这样写 // return [...new Set(arr)] } console.log(noRepeat(arr)) // (4) [1, 2, 5, 6] 利用 Map const arrs = [1,2,2,'2',5,6,6] const noRepeat = (arr) => { const mapData = new Map() for (let i = 0; i "},"src/frontEnd/handWritten/深拷贝.html":{"url":"src/frontEnd/handWritten/深拷贝.html","title":"深拷贝","keywords":"","body":"手写：深拷贝 以下几种方法都可以实现深拷贝，各有优劣 利用 JSON 方法 // 假定 a 是要拷贝的对象 const res = JSON.parse(JSON.stringify(a)) 这种方法的缺点： 不支持拷贝正则，Date，undefined,函数 不支持环形引用 使用递归： 递归 判断类型，不用类型用不同的方法拷贝 检查环形引用 不拷贝继承过来的属性 const deepClone = (param, mapData) => { if (!mapData) { // 将 mapData 映射作为参数传进函数体内，防止多次深拷贝创建的 mapData 相互影响， mapData = new Map() } if (param instanceof Object) { // 如果 params 是对象需要单独处理 if (mapData.get(param)) { return mapData.get(param) } let result = undefined if (param instanceof Function) { // 如果是函数 if (param.prototype) { // 如果是普通函数 result = function () { param.apply(this, arguments) } } else { // 不是普通函数，是箭头函数（箭头函数没有 prototye 属性） result = () => { param.call(undefined, ...arguments) } } } else if (param instanceof Array) { // 如果是数组 result = [] } else if (param instanceof Date) { // 如果是日期 result = new Date(param - 0) // 利用时间戳去重新生成一个日期 }else if (param instanceof RegExp) { // 如果是正则 // result = new RegExp(param) result = new RegExp(param.source, a.flags) } else { // 其他则视为普通对象 result = {} } // 在这里利用 mapData 去存储已经拷贝过的值，用来避免遇到 环形引用。 mapData.set(param, result) // 这里将其他属性，依次遍历重新拷贝一遍 // const keys = Object.keys(param) for(let key in param) { if (param.hasOwnProperty(key)) { // 只遍历 param 自己的可枚举属性，不遍历继承过来的属性 result[key] = deepClone(param[key], mapData) } } return result } else { // param 是基本数据类型 return param } } 使用： const a = { one: [1,2,3,4, [9,8,7]], two: function () { console.log('two') }, three: new Date(), four: () => { console.log('箭头函数') } } "},"src/frontEnd/handWritten/Promise.all.html":{"url":"src/frontEnd/handWritten/Promise.all.html","title":"Promise.all","keywords":"","body":"手写：Promise.all Promise.all2 = (arrayList) => { return new Promise((resolve, reject) => { const result = [] let count = 0 arrayList.map((item, index) => { item.then((data) => { result[index] = data count = count + 1 if (count === arrayList.length - 1) { resolve(result) } }, (reason) => { reject(reason) }) }) }) } "},"src/frontEnd/handWritten/ajax.html":{"url":"src/frontEnd/handWritten/ajax.html","title":"Ajax","keywords":"","body":"手写：Ajax var XMLRequest = new XMLHTTPRequest() XMLRequest.open('GET', '/xxx?', true) // 第三个参数：是否为异步 // 如果是 post 请求，必须要加上请求头。setRequestHeader 必须在 open 之后，send 之前 // XMLRequest.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); XMLRequest.onreadystatechange = function () { if (XMLRequest.readyState === 4) { if (XMLRequest.status >= 200 && XMLRequest.status "},"src/frontEnd/handWritten/防抖、节流.html":{"url":"src/frontEnd/handWritten/防抖、节流.html","title":"防抖、节流","keywords":"","body":"手写：防抖、节流函数 防抖： 使用场景： 比如，当需要根据窗口大小调整页面内容的时候，如果用户不断的放大缩小页面，会导致不停的计算。 使用防抖函数，只有当用户停止调整页面窗口的时候，再去计算。 function goBack() { console.log('回到泉水') } const timer = null function B() { if (timer) { // 如果回城被打断或者再次按回城键，则需要再次调用回城方法，从 0 开始回城 clearTimeout(timer) } timer = setTimeout(() => { goBack() timer = null }, 3000) } // 防抖升级版： const debounce = (fn, time) => { const timer = null return () => { if (timer) { clearTimeout(timer) } else { timer = setTimeout(() => { fn() timer = null }, time) } } } // 使用： const Back = debounce(B, 3000) 节流： 使用场景： 页面上某个按钮，3秒内只能点击一次。类似这样的功能的时候，需要用到节流。 function shanXian() { console.log('向指定方向闪现一段距离') } const isCD = false const timer = null function D() { if (isCD) { return } shanXian() isCD = true timer = setTimeout(() => { isCD = false timer = null }, 3000) } // 节流升级版： // 能够将任意函数改为截流函数： const throttle = (fn, time) => { const isCD = false const timer = null return () => { if (isCD) { return } fn() isCD = true timer = setTimeout(() => { isCD = false timer = null }, time) } } "},"src/frontEnd/handWritten/实现继承.html":{"url":"src/frontEnd/handWritten/实现继承.html","title":"实现继承","keywords":"","body":"手写：实现继承 ES5 function Animal(legs) { this.legsNumber = legs } Animal.prototype.kind = function(kind) { console.log(kind) } // Dog 继承 Animal function Dog(name) { Animal.call(this, 2) // Dog 继承 Animal 的属性 this.name = name } // Dog.prototype.__proto__ = Animal.prototype 下面三句代码代替这段代码，因为浏览器不支持直接修改 __proto__ 属性 let emptyAnimal = function() {} // 声明一个空的函数，用来替换 Animal emptyAnimal.prototype = Animal.prototype // 将 Animal 函数体中的代码替换掉，因为在 Animal.call(this. 2) 中已经执行过了。 Dog.prototype = new emptyAnimal() // 因为 new 的操作中会执行构造函数，所以需要提前清除构造函数的函数体，防止多添加属性 ES6 class Animal { constructor(legs) { this.legsNumber = legs } run() { console.log('run') } } class Dog extends Animal { constructor(name) { super(2) this.name = name } say() { console.log('say') } } "},"src/frontEnd/handWritten/实现一个类.html":{"url":"src/frontEnd/handWritten/实现一个类.html","title":"实现一个类","keywords":"","body":"手写：实现一个类 ES5 function Dog1 (name) { this.name = name this.eyes = 2 } Dog.prototype.say = function () { console.log(\"汪\") } Dog.prototype.run = function() { conslle.log('跑') } const dog1 = new Dog1('第一个') ES6 class Dog2 { constructor(name) { this.name = name this.eyes = 2 } say() { console.log('汪') } run () { console.log('跑') } } const dog2 = new Dog2('第二个') "},"src/frontEnd/handWritten/发布订阅.html":{"url":"src/frontEnd/handWritten/发布订阅.html","title":"发布订阅","keywords":"","body":"手写：发布订阅 class Event { constructor() { this.eventMap = {} } // 添加订阅 on(type, callback) { this.eventMap[type] = this.eventMap[type] || [] this.eventMap[type].push(callback) } // 发布 emit(type, ...args) { if (!this.eventMap[type]) { return } this.eventMap[type].forEach((item) => { item(args) }) } // 接触订阅 off(type, callback) { if (!this.eventMap[type]) { return } const index = this.eventMap[type].indexOf(callback) if (index { callback(params) this.off(type, fn) } this.on(type, fn) } } // 以下可以不看 // const eventBus = { // map: {}, // // 订阅事件 // on: (name, fn) => { // eventBus.map[name] = eventBus.map[name] || [] // eventBus.map[name].push(fn) // }, // emit: (name, params) => { // if (!eventBus.map[name]) { return } // eventBus.map((item) => { // item(params) // }) // }, // off: (name, fn) => { // if (!eventBus.map[name]) { return } // const index = eventBus.map[name].indexOf(fn) // if (index "},"src/gitOperate/":{"url":"src/gitOperate/","title":"Git","keywords":"","body":"git 常用命令 合并commit 为一个 // 合并指定版本号（不包含此版本） git rebase -i [commitid] :%s/pick/s/g 全局替换 pick 为 s 拉取远程分支到本地 git checkout -b 本地新建的分支名 origin/远程分支名 "},"src/regEx/":{"url":"src/regEx/","title":"正则表达式","keywords":"","body":"数字每三位添加逗号 String(123456789).replace(/(? "}}